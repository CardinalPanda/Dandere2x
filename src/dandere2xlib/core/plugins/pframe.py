from wrappers.frame.frame import DisplacementVector
from wrappers.frame.frame import Frame


# This is the inversion (sort of) function of what Dandere2x_cpp's pframe does (which is more commented).
# Dandere2x_CPP tells us how to take apart an image using vectors, this tells us how to put the upscaled version
# back together.

def pframe_image(context,
                 frame_next: Frame, frame_previous: Frame, frame_residual: Frame,
                 list_residual: list, list_predictive: list):
    """
    Create a new image using residuals and predictive vectors.
    Roughly, we can describe this method as

        frame_next = Transfrom(frame_previous, list_predictive) + frame_residuals.

    Although frame_residuals needs to also be transformed.

    Method Tasks:
        - Move blocks from frame_previous into frame_next using list_predictive
        - Move blocks from frame_residual into frame_next using list_residuals
    """

    # load context
    predictive_vectors = []
    residual_vectors = []
    scale_factor = int(context.scale_factor)
    block_size = context.block_size
    bleed = context.bleed

    # load lists into vector displacements
    for x in range(int(len(list_residual) / 4)):
        residual_vectors.append(DisplacementVector(int(list_residual[x * 4 + 0]),
                                                   int(list_residual[x * 4 + 1]),
                                                   int(list_residual[x * 4 + 2]),
                                                   int(list_residual[x * 4 + 3])))

    # Neat optimization trick - there's no need for pframe to copy over a block if the vectors
    # point to the same place. In merge.py we just need to load the previous frame into the current frame
    # To reach this optimization. 
    for x in range(int(len(list_predictive) / 4)):
        if int(list_predictive[x * 4 + 0]) != int(list_predictive[x * 4 + 1]) and \
                int(list_predictive[x * 4 + 2]) != int(list_predictive[x * 4 + 3]):
            predictive_vectors.append(DisplacementVector(int(list_predictive[x * 4 + 0]),
                                                         int(list_predictive[x * 4 + 1]),
                                                         int(list_predictive[x * 4 + 2]),
                                                         int(list_predictive[x * 4 + 3])))

    # copy over blocks from one image to the others using the vectors generated by waifu2x_cpp
    for vector in predictive_vectors:
        frame_next.copy_block(frame_previous, block_size * scale_factor,
                              vector.x_2 * scale_factor,
                              vector.y_2 * scale_factor,
                              vector.x_1 * scale_factor,
                              vector.y_1 * scale_factor)

    # copy over inversion vectors (the difference images) into new image using vectors generated by waifu2x_cpp
    for vector in residual_vectors:
        frame_next.copy_block(frame_residual, block_size * scale_factor,
                              (vector.x_2 * (block_size + bleed * 2)) * scale_factor + (bleed * scale_factor),
                              (vector.y_2 * (block_size + bleed * 2)) * scale_factor + (bleed * scale_factor),
                              vector.x_1 * scale_factor,
                              vector.y_1 * scale_factor)

    return frame_next
